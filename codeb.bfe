%{
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "codeb.h"

int print_load_array_direct_index(tree_node_t* idNode, tree_node_t* directNode);
int print_load_array_reg_index(tree_node_t* idNode, tree_node_t* regNode);
int print_add_direct_reg(tree_node_t* regNode, tree_node_t* directNode);
int print_add_reg_reg(tree_node_t* regA, tree_node_t* regB);
int print_mult_direct_reg(tree_node_t* regNode, tree_node_t* directNode);
int print_mult_reg_reg(tree_node_t* regA, tree_node_t* regB);
int load_symbol_into_reg(tree_node_t* node);

%}

%start stmt
%term OP_STMT=1 OP_NUM=2 OP_ID=3 OP_ADD=4 OP_MULT=5 OP_MINUS=6 OP_RET=7 OP_ARRAY_ACCESS=8 OP_GT=9 OP_NEQ=10 OP_IF=11 OP_DEFINITION=12 OP_ASSIGNMENT=13

%%

stmt: OP_RET(directValue) # 1 # printf("movq $%d, %rax\nleave\nret\n\n", bnode->left->value);
stmt: OP_RET(regValue) # 1 # printf("movq %s, %rax\nleave\nret\n\n", regs[bnode->left->value]);

stmt: OP_GT(directValue, directValue) # 0 # print_comparison_gt_direct_direct(bnode);
stmt: OP_GT(directValue, regValue) # 1 # print_comparison_gt_direct_reg(bnode);
stmt: OP_GT(regValue, directValue) # 1 # print_comparison_gt_reg_direct(bnode);
stmt: OP_GT(regValue, regValue) # 2 # print_comparison_gt_reg_reg(bnode);

stmt: OP_NEQ(directValue, directValue) # 0 # print_comparison_neq_direct_direct(bnode);
stmt: OP_NEQ(directValue, regValue) # 1 # print_comparison_neq_direct_reg(bnode);
stmt: OP_NEQ(regValue, directValue) # 1 # print_comparison_neq_reg_direct(bnode);
stmt: OP_NEQ(regValue, regValue) # 2 # print_comparison_neq_reg_reg(bnode);

stmt: OP_DEFINITION(directValue) # 1 # print_def_direct(bnode);
stmt: OP_DEFINITION(regValue) # 1 # print_def_reg(bnode);

directValue: num # 0
directValue: OP_ADD(directValue, directValue) # 0 # bnode->value = bnode->left->value + bnode->right->value;
directValue: OP_MULT(directValue, directValue) # 0 # bnode->value = bnode->left->value * bnode->right->value;
directValue: OP_MINUS(directValue, directValue) # 0 # bnode->value = bnode->left->value * bnode->right->value;

regValue: id # 0

regValue: OP_ARRAY_ACCESS(id, directValue) # 1 # bnode->value = print_load_array_direct_index(bnode->left, bnode->right);
regValue: OP_ARRAY_ACCESS(id, regValue) # 1 # bnode->value = print_load_array_reg_index(bnode->left, bnode->right);

regValue: OP_ADD(directValue, regValue) # 1 # bnode->value = print_add_direct_reg(bnode->right, bnode->left);
regValue: OP_ADD(regValue, directValue) # 1 # bnode->value = print_add_direct_reg(bnode->left, bnode->right);
regValue: OP_ADD(regValue, directValue) # 1 # bnode->value = print_add_direct_reg(bnode->left, bnode->right);
regValue: OP_ADD(regValue, regValue) # 2 # bnode->value = print_add_reg_reg(bnode->left, bnode->right);

regValue: OP_MULT(directValue, regValue) # 1 # bnode->value = print_mult_direct_reg(bnode->right, bnode->left);
regValue: OP_MULT(regValue, directValue) # 1 # bnode->value = print_mult_direct_reg(bnode->left, bnode->right);
regValue: OP_MULT(regValue, directValue) # 1 # bnode->value = print_mult_direct_reg(bnode->left, bnode->right);
regValue: OP_MULT(regValue, regValue) # 2 # bnode->value = print_mult_reg_reg(bnode->left, bnode->right);

regValue: OP_MINUS(directValue, regValue) # 1 # bnode->value = print_mult_direct_reg(bnode->right, bnode->left);

num: OP_NUM  # 0
id: OP_ID # 0

%%

extern int yyparse(void);
void burm_reduce(NODEPTR_TYPE bnode, int goalnt);

void print_def_direct(tree_node_t* node) {
	symbol_t* symbol = get_symbol_by_name(node->id, node->symbols);
	printf("movq $%d, %d(%rbp)\t# definition of var %s\n\n", node->left->value, symbol->frameOffset, node->id);
}

void print_def_reg(tree_node_t* node) {
	symbol_t* symbol = get_symbol_by_name(node->id, node->symbols);
	int regExpr = (node->left->id != NULL ? load_symbol_into_reg(node->left) : node->left->value);
	printf("movq %s, %d(%rbp)\t# definition of var %s\n\n", regs[regExpr], symbol->frameOffset, node->id);
}

void print_comparison_gt_direct_direct(tree_node_t* node) {
	if (node->left->value > node->right->value && node->condition->inversed) {
		printf("jmp L_%s\t# would-be conditional jmp -> always true\n", node->condition->failTarget);
	}
	else {
		printf("# here would be a conditional jump that is always false\n");
	}
	printf("\n");
}

void print_comparison_gt_direct_reg(tree_node_t* node) {
	int reg = (node->right->id != NULL ? load_symbol_into_reg(node->right) : node->right->value);
	printf("cmp $%d, %s\t#cmp with %s\n", node->left->value, regs[reg], node->right->id != NULL ? node->right->id : "<intermediate>");
	if(node->condition->inversed)
		printf("jg L_%s\n", node->condition->failTarget);
	else
		printf("jle L_%s\n", node->condition->failTarget);
	printf("\n");
}

void print_comparison_gt_reg_direct(tree_node_t* node) {
	int reg = (node->left->id != NULL ? load_symbol_into_reg(node->left) : node->left->value);
	printf("cmp %s, $%d\t#cmp with %s\n", regs[reg], node->right->value, node->left->id != NULL ? node->left->id : "<intermediate>");
	if(node->condition->inversed)
		printf("jg L_%s\n", node->condition->failTarget);
	else
		printf("jle L_%s\n", node->condition->failTarget);
	printf("\n");
}

void print_comparison_gt_reg_reg(tree_node_t* node) {
	int regLeft = (node->left->id != NULL ? load_symbol_into_reg(node->left) : node->left->value);
	int regRight = (node->right->id != NULL ? load_symbol_into_reg(node->right) : node->right->value);

	printf("cmp %s, %s\t#cmp %s with %s\n", regs[regLeft], regs[regRight], node->left->id != NULL ? node->left->id : "<intermediate>", node->right->id != NULL ? node->right->id : "<intermediate>");
	if(node->condition->inversed)
		printf("jg L_%s\n", node->condition->failTarget);
	else
		printf("jle L_%s\n", node->condition->failTarget);
	printf("\n");
}

void print_comparison_neq_direct_direct(tree_node_t* node) {
	if (node->left->value != node->right->value && node->condition->inversed) {
		printf("jmp L_%s\t# would-be conditional jmp -> always true\n", node->condition->failTarget);
	}
	else {
		printf("# here would be a conditional jump that is always false\n");
	}
	printf("\n");
}

void print_comparison_neq_direct_reg(tree_node_t* node) {
	int reg = (node->right->id != NULL ? load_symbol_into_reg(node->right) : node->right->value);
	printf("cmp $%d, %s\t#cmp with %s\n", node->left->value, regs[reg], node->right->id != NULL ? node->right->id : "<intermediate>");
	if(node->condition->inversed)
		printf("jne L_%s\n", node->condition->failTarget);
	else
		printf("je L_%s\n", node->condition->failTarget);
	printf("\n");
}

void print_comparison_neq_reg_direct(tree_node_t* node) {
	int reg = (node->left->id != NULL ? load_symbol_into_reg(node->left) : node->left->value);
	printf("cmp %s, $%d\t#cmp with %s\n", regs[reg], node->right->value, node->left->id != NULL ? node->left->id : "<intermediate>");
	if(node->condition->inversed)
		printf("jne L_%s\n", node->condition->failTarget);
	else
		printf("je L_%s\n", node->condition->failTarget);
	printf("\n");
}

void print_comparison_neq_reg_reg(tree_node_t* node) {
	int regLeft = (node->left->id != NULL ? load_symbol_into_reg(node->left) : node->left->value);
	int regRight = (node->right->id != NULL ? load_symbol_into_reg(node->right) : node->right->value);

	printf("cmp %s, %s\t#cmp %s with %s\n", regs[regLeft], regs[regRight], node->left->id != NULL ? node->left->id : "<intermediate>", node->right->id != NULL ? node->right->id : "<intermediate>");
	if(node->condition->inversed)
		printf("jne L_%s\n", node->condition->failTarget);
	else
		printf("je L_%s\n", node->condition->failTarget);
	printf("\n");
}

int print_load_array_direct_index(tree_node_t* idNode, tree_node_t* directNode) {
	symbol_t* symbol = get_symbol_by_name(idNode->id, idNode->symbols);
	int destReg = acquire_reg(idNode->symbols);
	printf("movq %d(%rbp), %s\t#load array ptr for %s\n", symbol->frameOffset, regs[destReg], idNode->id);
	printf("movq (%s, %d, 8), %s\n\n", regs[destReg], directNode->value, regs[destReg]);
	return destReg;
}

int print_load_array_reg_index(tree_node_t* idNode, tree_node_t* regNode) {
	symbol_t* symbol = get_symbol_by_name(idNode->id, idNode->symbols);
	int srcReg = (regNode->id != NULL ? load_symbol_into_reg(regNode) : regNode->value);
	int destReg = acquire_reg(idNode->symbols);
	printf("movq %d(%rbp), %s\t#load array ptr for %s\n", symbol->frameOffset, regs[destReg], idNode->id);
	printf("movq (%s, %s, 8), %s\n\n", regs[destReg], regs[srcReg], regs[destReg]);
	return destReg;
}

int print_add_direct_reg(tree_node_t* regNode, tree_node_t* directNode) {
	int srcReg = (regNode->id != NULL ? load_symbol_into_reg(regNode) : regNode->value);
	int destReg = acquire_reg(regNode->symbols);
	printf("movq $%d, %s\n", directNode->value, regs[destReg]);
	printf("addq %s, %s\n\n", regs[srcReg], regs[destReg]);
	return destReg;
}

int print_add_reg_reg(tree_node_t* regA, tree_node_t* regB) {
	int srcAReg = (regA->id != NULL ? load_symbol_into_reg(regA) : regA->value);
	int srcBReg = (regB->id != NULL ? load_symbol_into_reg(regB) : regB->value);
	int destReg = acquire_reg(regA->symbols);

	printf("movq %s, %s\n", regs[srcAReg], regs[destReg]);
	printf("addq %s, %s\n\n", regs[srcBReg], regs[destReg]);
	return destReg;
}

int print_mult_direct_reg(tree_node_t* regNode, tree_node_t* directNode) {
	int srcReg = (regNode->id != NULL ? load_symbol_into_reg(regNode) : regNode->value);
	int destReg = acquire_reg(regNode->symbols);
	printf("movq $%d, %s\n", directNode->value, regs[destReg]);
	printf("imul %s, %s\n\n", regs[srcReg], regs[destReg]);
	return destReg;
}

int print_mult_reg_reg(tree_node_t* regA, tree_node_t* regB) {
	int srcAReg = (regA->id != NULL ? load_symbol_into_reg(regA) : regA->value);
	int srcBReg = (regB->id != NULL ? load_symbol_into_reg(regB) : regB->value);
	int destReg = acquire_reg(regA->symbols);

	printf("movq %s, %s\n", regs[srcAReg], regs[destReg]);
	printf("imul %s, %s\n\n", regs[srcBReg], regs[destReg]);
	return destReg;
}

int load_symbol_into_reg(tree_node_t* node) {
	int regId = get_symbol_reg(node->id, node->symbols);
	if (regId == -1){
		regId = assign_reg_to_symbol(node->id, node->symbols);
		symbol_t* symbol = get_symbol_by_name(node->id, node->symbols);
		printf("movq %d(%rbp), %s\t#load symbol %s\n", symbol->frameOffset, regs[regId], node->id);
	}
	return regId;
}

void invoke_burm(NODEPTR_TYPE root) {
	burm_label(root);
	burm_reduce(root, 1);
}
